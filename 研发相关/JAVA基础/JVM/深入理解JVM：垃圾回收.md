# 深入理解JVM：垃圾回收

## 需要回收的对象

- 引用计数算法

    给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。

    因为两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。所以 `JVM` 并没有选用引用计数算法来管理内存。

- 可达性分析算法

    算法：通过一系列被称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，证明此对象是不可用的。

    GC Roots对象：

    - 虚拟机栈中引用的对象
    - 方法区中类静态属性引用的对象
    - 方法区中的常量引用的对象
    - 本地方法栈中引用的对象

- 引用类型

    无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与  `引用` 有关。

    `Java` 对引用的概念进行了扩充，将引用分为：

    - 强引用

        只要强引用存在，垃圾回收器永远不会回收调掉被引用的对象。

        使用 new 一个新对象的方式来创建强引用。
        
        ```
        Object obj = new Object();
        ```

    - 软引用

        用来描述一些还有用但是并非必需的对象。

        在系统将要发生内存溢出异常之前，将会对这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出溢出异常。

        使用 `SoftReference` 类来实现软引用。

    - 弱引用

        只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够，都会被回收。

        使用 `WeakReference` 类来实现弱引用。

    - 虚引用

        一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

        使用 `PhantomReference` 来实现虚引用。

    - 回收方法区

        永久代的垃圾收集效率非常低。

        主要是对常量池的回收和对类的卸载。

        类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载：

        - 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
        - 加载该类的 ClassLoader 已经被回收。
        - 该类对应的 java.lang.Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。


## 垃圾收集算法

- 标记-清除算法

    ![mark](http://of0qa2hzs.bkt.clouddn.com/blog/180408/H3aaA062D4.png?imageslim)

    > 对需要回收的对象进行标记，然后直接清除。是最基础的收集算法，后续的收集算法都是基于这种思路对其不足进行改进而得到的。

    不足：

    - 标记和清除两个过程的 `效率都不高`

    - 标记清除之后会 `产生大量不连续的内存碎片`，内存碎片过多可能导致无法给大对象分配内存

- 复制算法

    ![mark](http://of0qa2hzs.bkt.clouddn.com/blog/180408/I5kL1jHHBm.png?imageslim)

    > 将内存划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完，就将还存活的对象复制到另一块上面，然后把已经使用过的内存空间一次清理掉。

    - 好处：不用考虑内存碎片的问题，实现简单，运行高效。

    - 不足：只用到了内存的一半空间

    - 改进：现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将内存划分为大小相等的两块，而是分为一块较大的 `Eden` 空间和两块较小的 `Survior` 空间，每次使用 `Ede`n 空间和其中一块 `Survivor`。在回收时，将 `Eden` 和 `Survivor` 中还存活着的对象一次性复制到另一块 `Survivor` 空间上，最后清理 `Eden` 和 使用过的那一块 `Survivor`。`HotSpot` 虚拟机的 `Eden` 和 `Survivor` 的大小比例默认为 8:1，保证了内存的利用率达到 `90 %`。如果每次回收有多于 `10%` 的对象存活，那么一块 `Survivor` 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间。

- 标记-整理算法

    ![mark](http://of0qa2hzs.bkt.clouddn.com/blog/180408/EJGaE5Addh.png?imageslim)

    > 让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

    - 原因：复制收集算法在对象存活率较高时就要进行比较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，所以老年代一般不能直接选用这种算法。

- 分代收集算法

    > 现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。

    一般将 Java 堆分为新生代和老年代。

    - 新生代使用：复制算法（新生代中，每次垃圾收集时都会发现大批对象死去，只有少量存活）

    - 老年代使用：标记 - 清理 或者 标记 - 整理 算法（老年代对象存活率高并且缺乏分配担保）

## 垃圾收集器

![mark](http://of0qa2hzs.bkt.clouddn.com/blog/180408/f30FaD4E9a.png?imageslim)

图为 `HotSpot` 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用

- Serial 收集器

- ParNew 收集器

- Parallel Scavenge 收集器

- Serial Old 收集器

- Parallel Old 收集器

- CMS 收集器

- G1 收集器

## 内存分配与回收策略

> 对象的内存分配，大方向上讲就是在堆上分配。对象主要分配在新生代的 Eden 区上，少数情况下也可能直接分配在老年代中。

- 优先在 Eden 分配

- 大对象直接进入老年代

- 长期存活的对象进入老年代

- 动态对象年龄判定

- 空间分配担保
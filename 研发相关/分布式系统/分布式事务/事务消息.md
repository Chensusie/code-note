# 事务消息

本地消息表的模式无法支持本地事务执行和消息发送一致性的问题，如果能在本地事务执行和发消息这两个操作上加上事务，那岂不是完美。

基于这个思路， 在 `MQ` 中存储消息的状态才是真理，消息生产者先把消息发送给 `MQ` ，此时消息状态为`“待确认”`，接着生产者去执行本地事务，如果执行成功就给 `MQ` 发送消息让他更改消息状态为 `“待发送”` 并发送消息，如果执行失败则删除消息。

这样就保证了本地事务和消息发送一致性问题。

## 事务消息模型

![20201222160136](http://cdn.heroxu.com/20201222160136.png)

- 首先事务发起方先往 `MQ` 发送一条预读消息，这条消息与普通消息的区别在于他只对 `MQ` 可见不会向下传播。
- `MQ` 接受到消息后，先进行持久化，则存储中会新增一条状态为待发送的消息，接着给事务发起方返回处理完成的 `ACK`；事务发起方收到处理完成的 `ACK` 之后开始执行本地事务。
- 发起方会根据本地事务的执行状态来决定这个预读消息是应该继续往前还是回滚。另外 `MQ` 也应该支持自己反查来解决异常情况，如果发起方本地事务已经执行完毕发送消息到MQ,但是消息因为网络原因丢失，那么怎么解决。所以这个反查机制很重要。
- 本地事务执行成功以后， `MQ` 也接收到成功通知，接着将消息状态更新为可发送，然后将消息推送给下游的消费者，这个时候消费者就可以去处理自己的本地事务 。


## 事务消息使用注意点

- 消息回查

    事务执行之后的消息可能会有投递失败的情况，需要允许 `MQ` 反查这个事务是否成功，没成功就返回未知。因为有可能事务还在执行，会进行多次查询。

- 消费幂等

    由于 `MQ` 通常都会保证消息能够投递成功，因此，如果业务没有及时返回 `ACK` 结果，那么就有可能造成 `MQ` 的重复消息投递问题。因此，对于消息最终一致性的方案，消息的消费者必须要对消息的消费支持幂等，不能造成同一条消息的重复消费的情况。


## 参考

- [Kafka 事务特性分析](https://zhuanlan.zhihu.com/p/42046847)

- [大写的服，看完这篇你还不懂RocketMQ算我输](https://jishuin.proginn.com/p/763bfbd2f1c5)

- [还不知道事务消息吗？这篇文章带你全面扫盲！](https://juejin.cn/post/6844904106532962311)

- [消息队列之事务消息，RocketMQ 和 Kafka 是如何做的](https://juejin.im/post/6867040340797292558)

- [kafka系列九、kafka事务原理、事务API和使用场景](https://www.cnblogs.com/wangzhuxing/p/10125437.html)

- [Kafka设计-恰好一次和事务消息](https://cloud.tencent.com/developer/article/1600510)

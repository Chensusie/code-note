# CAP原则

## Overview 

`CAP` 原则又称 `CAP` 定理，指的是在一个分布式系统中， `Consistency`（一致性）、`Availability`（可用性）、`Partition tolerance`（分区容错性），三者不可得兼，最多只能同时满足其中的 `2` 个。

![20191212103254](http://cdn.heroxu.com/20191212103254.png)

- 一致性（`Consistency`）

    在分布式系统中的所有数据备份，在同一时刻是否同样的值。（严格的一致性，所有节点访问同一份最新的数据副本）

- 可用性（`Availability`）

    在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性，不保证获取的数据为最新数据，但是保证最终一致性）

- 分区容错性（`Partition tolerance`）

    分布式系统在遇到任何网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 `C` 和 `A` 之间做出选择。

## CAP原则论证

#### 基本场景

在一个CAP的基本场景中，网络中有两个节点N1和N2，可以简单的理解N1和N2分别是两台计算机，他们之间网络可以连通，N1中有一个应用程序A，和一个数据库V，N2也有一个应用程序B2和一个数据库V。现在，A和B是分布式系统的两个部分，V是分布式系统的数据存储的两个子数据库。

![20191212110038](http://cdn.heroxu.com/20191212110038.png)

- 在满足一致性的时候，N1和N2中的数据是一样的，V0=V0。
- 在满足可用性的时候，用户不管是请求N1或者N2，都会得到立即响应。
- 在满足分区容错性的情况下，N1和N2有任何一方宕机，或者网络不通的时候，都不会影响N1和N2彼此之间的正常运作。

#### 网络正常运行，实际上同时满足CAP

![20191212111643](http://cdn.heroxu.com/20191212111643.png)

用户向N1机器请求数据更新，程序A更新数据库V0为V1。分布式系统将数据进行同步操作M，将V1同步的N2中V0，使得N2中的数据V0也更新为V1，N2中的数据再响应N2的请求。

- 一致性：N1和N2的数据库V之间的数据是否完全一样。
- 可用性：N1和N2的对外部的请求能否做出正常的响应。
- 分区容错性：N1和N2之间的网络是否互通。

#### 网络异常，CAP只能同时满足其中2个

![20191212111844](http://cdn.heroxu.com/20191212111844.png)

假设在N1和N2之间网络断开的时候，有用户向N1发送数据更新请求，那N1中的数据V0将被更新为V1。由于网络是断开的，所以分布式系统同步操作M，所以N2中的数据依旧是V0。这个时候，有用户向N2发送数据读取请求，由于数据还没有进行同步，应用程序没办法立即给用户返回最新的数据V1，怎么办呢？
这里有两种选择：

- 第一：牺牲数据一致性，保证可用性。响应旧的数据V0给用户。
- 第二：牺牲可用性，保证数据一致性。阻塞等待，直到网络连接恢复，数据更新操作M完成之后，再给用户响应最新的数据V1。

#### 总结

实际上，对于分布式系统来说，并不是 `CAP` 只能同时满足其中的 `2` 个，而是当网络出现问题时：因为 `P` 必须满足，所以只能再 `A` 和 `C` 中二选一。

## 取舍策略

因为 `CAP` 最多只能同时满足其中的 `2` 个，所以不得不做个取舍。

- CA without P

    如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。传统的关系型数据库RDBMS：Oracle、MySQL就是CA。

- CP without A

    如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实不少，最典型的就是分布式数据库，如Redis、HBase等。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。

- AP wihtout C

    要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。

## 主流分布式系统是如何选择的

|            | Eureka | Consul | Zookeeper            | Nacos | Etcd |
| ---------- | ------ | ------ | -------------------- | ----- | ---- |
| CAP        | AP     | CP     | CP                   | AP/CP   | CP   |
| 一致性算法 | 无     | Raft   | ZAB（类 PAXOS 协议） | Raft  | Raft |

对于`AP` 来说实际上，不用关心一致性算法，所以 `Eureka` 中没有使用任何的数据强一致性算法保证不同集群间的 `Server` 的数据一致，仅通过数据拷贝的方式争取注册中心数据的最终一致性。

而像 `Zookeeper` 这种分布式协调组件，数据的一致性是他们最最基本的要求。所以在极端环境下， `ZooKeeper` 可能会丢弃一些请求，消费者程序需要重新请求才能获得结果，也要保证数据一致性。

对于 `Nacos` 来说，实现 `AP` 的同时，也使用了一致性算法 `Raft` ，[Nacos 是如何同时实现AP与CP的](https://www.liaochuntao.cn/2019/06/01/java-web-41/)。

## 延伸阅读

对于一个分布式系统来说。 `P` 是一个基本要求， `CAP` 三者中，只能在 `CA` 两者之间做权衡，并且要想尽办法提升 `P` 。
某些情况下，`AP` 与 `CP` 的选择，可以看下这些公司是如何选择的：

- [Eureka! Why You Shouldn’t Use ZooKeeper for Service Discovery](https://medium.com/knerd/eureka-why-you-shouldnt-use-zookeeper-for-service-discovery-4932c5c7e764)

- [阿里巴巴为什么不用 ZooKeeper 做服务发现？](http://jm.taobao.org/2018/06/13/%E5%81%9A%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%EF%BC%9F/)


## 参考

- [CAP原则(CAP定理)、BASE理论](https://www.cnblogs.com/duanxz/p/5229352.html)

- [CAP Theorem: Revisited](https://robertgreiner.com/cap-theorem-revisited/)

- [An Illustrated Proof of the CAP Theorem](https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/)

- [CAP 定理的含义](https://www.ruanyifeng.com/blog/2018/07/cap.html)

- [分布式系统的CAP理论](https://www.hollischuang.com/archives/666)
# TCC事务模型

`TCC` 是一种补偿型事务，该模型要求应用的每个服务提供 `try、confirm、cancel` 三个接口，它的核心思想是通过对资源的预留(提供中间态，如账户状态、冻结金额等)，尽早释放对资源的加锁，如果事务可以提交，则完成对预留资源的确认，如果事务要回滚，则释放预留的资源。

`TCC` 事务机制相比于 `XA` ，解决了其几个缺点：

- 解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。
- 同步阻塞：引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。
- 数据一致性，有了补偿机制之后，由业务活动管理器控制一致性

## TCC模型

`TCC` 模型完全交由业务实现，每个子业务都需要实现 `Try-Confirm-Cancel` 三个接口，对业务侵入大，资源锁定交由业务方。

- Try

    尝试执行业务，完成所有业务检查(一致性)，预留必要的业务资源(准隔离性)。

- Confirm

    确认执行业务，不再做业务检查。只使用 `Try` 阶段预留的业务资源， `Confirm` 操作满足幂等性。

- Cancel

    取消执行业务释放 `Try` 阶段预留业务资源。

![20201222113037](http://cdn.heroxu.com/20201222113037.png)

一个完整的业务活动由一个主业务服务与若干子业务服务组成：

- 主业务服务负责发起并完成整个业务活动；
- 业务服务提供 `TCC` 型业务操作；
- 业务活动管理器控制业务活动的一致性，它登记业务活动中的操作，并在业务活动提交时确认所有的 `TCC` 型操作的 `Confirm` 操作，在业务活动取消时调用所有 `TCC` 型操作的 `Cancel` 操作。

比如一个转账操作：

- 首先在 `Try` 阶段先把转账者的钱包冻结起来。
- 在 `Confirm` 阶段，调用转账接口操作转账，转账成功后解冻。
- 如果 `Confirm` 阶段成功那么就转账成功，否则执行转账失败确认逻辑。

基于 `TCC` 实现分布式事务，会将原来只需要一个接口就可以实现的逻辑拆分为 `Try、Confirm、Cancel` 三个接口，所以代码实现复杂度相对较高，需要在业务中写很多的补偿机制代码。

`TCC` 将事务提交划分成两个阶段， `Try` 即为一阶段， `Confirm` 和 `Cancel` 是二阶段并行的两个分支，二选一。从阶段划分上非常像 `2PC` ，我们是否可以说 `TCC` 是一种 `2PC` 或者 `2PC` 变种呢？

对比一下 `XA` 事务模型， `TCC` 的两阶段提交与 `XA` 还是有一些区别：

- `2PC` 的操作对象在于资源层，对于开发人员无感知；而 `TCC` 的操作在于业务层，具有较高开发成本。
- `2PC` 是一个整体的长事务，也是刚性事务；而 `TCC` 是一组的本地短事务，是柔性事务。
- `2PC` 的 `Prepare(表决阶段)` 进行了操作表决；而 `TCC` 的 `Try` 并没有表决准备，直接兼备资源操作与准备能力。
- `2PC` 是全局锁定资源，所有参与者阻塞交互等待 `TM` 通知；而 `TCC` 的资源锁定在于 `Try` 操作，业务方可以灵活选择业务资源的锁定粒度。

## TCC的业务策略

​`TCC` 为了解决网络不可靠引起的异常情况，要求业务方在设计上要遵循三个策略：

- 允许空回滚

    原因是异常发生在阶段一时，部分参与方没有收到 `Try` 请求从而触发整个事务的 `Cancel` 操作；`Try` 失败或者没有执行 `Try` 操作的参与方收到 `Cancel` 请求时，要进行空回滚操作。

- 保持幂等性

    原因是异常发生在阶段二时，比如网络超时，则会重复调用参与方的 `Confirm/Cancel` 方法，因此 `Confirm/Cancel` 方法必须保证幂等性。

- 防止资源悬挂
    
    原因网络异常导致两个阶段无法保证严格的顺序执行，出现参与方侧 `Try` 请求比 `Cancel` 请求更晚到达的情况， `Cancel` 会执行空回滚而确保事务的正确性，但是此时 `Try` 方法也不可以再被执行。

## TCC实现如何保证ACID

### 原子性

`TCC` 模型也使用 `2PC` 原子提交协议来保证事务原子性。 `Try` 操作对应 `2PC` 的一阶段准备（`Prepare`）；`Confirm` 对应 `2PC` 的二阶段提交（`Commit`）， `Cancel` 对应 `2PC` 的二阶段回滚（`Rollback`），可以说 `TCC` 就是应用层的 `2PC` 。

### 隔离性

`TCC` 分布式事务模型仅提供两阶段原子提交协议，保证分布式事务原子性。事务的隔离交给业务逻辑来实现。

隔离的本质是控制并发，防止并发事务操作相同资源而引起的结果错乱。

举个例子，比如金融行业里管理用户资金，当用户发起交易时，一般会先检查用户资金，如果资金充足，则扣除相应交易金额，增加卖家资金，完成交易。如果没有事务隔离，用户同时发起两笔交易，两笔交易的检查都认为资金充足，实际上却只够支付一笔交易，结果两笔交易都支付成功，导致资损。

可以发现，并发控制是业务逻辑执行正确的保证，但是像两阶段锁这样的并发访问控制技术要求一直持有数据库资源锁直到整个事务执行结束，特别是在分布式事务架构下，要求持有锁到分布式事务第二阶段执行结束，也就是说，分布式事务会加长资源锁的持有时间，导致并发性能进一步下降。

因此， `TCC` 模型的隔离性思想就是通过业务的改造，在第一阶段结束之后，从底层数据库资源层面的加锁过渡为上层业务层面的加锁，从而释放底层数据库锁资源，放宽分布式事务锁协议，提高业务并发性能。

还是以上面的例子举例：

- 第一阶段：检查用户资金，如果资金充足，冻结用户本次交易资金，这笔资金被业务隔离，不允许除本事务之外的其它并发事务动用。

- 第二阶段：扣除第一阶段预冻结的用户资金，增加卖家资金，完成交易。 采用业务加锁的方式，隔离用户冻结资金，在第一阶段结束后直接释放底层资源锁，该用户和卖家的其他交易都可以立刻并发执行，而不用等到整个分布式事务结束，可以获得更高的并发交易能力。

### 一致性

再来看看 `TCC` 分布式事务模型下的一致性实现。与 `XA` 协议实现一致性第一层语义类似，通过原子性保证事务的原子提交、业务隔离性控制事务的并发访问，实现分布式事务的一致性状态转变。

至于第二层语义：事务的中间状态不能被观察到。我们来看看，在 `SOA` 分布式应用环境下是否是必须的。

还是以账务服务举例。转账业务（用户 `A` 用户 `B`），由交易服务和账务服务组成分布式事务，交易服务作为主业务服务，账务服务作为从业务服务，账务服务的 `Try` 操作预冻结用户 `A` 的资金；`Commit` 操作扣除用户 `A` 的预冻结资金，增加用户 `B` 的可用资金；`Cancel` 操作解冻用户 `A` 的预冻结资金。

当账务服务执行完 `Try` 阶段后，交易主业务就可以 `Commit` 了，然后由 `TCC` 框架调用账务的 `Commit` 阶段。在账务 `Commit` 阶段还没执行结束的时候，用户 `A` 可以查询到自己的余额已扣除，但是，此时用户 `B` 的可用资金还没增加。

从系统的角度来看，确实有问题与不确定性。在第一阶段执行结束到第二阶段执行结束之间，有一段时间的延时，在这段时间内，看似任何用户都不享有这笔资产。

但是，从用户的角度来考虑这个问题的话，这个时间间隔可能就无所谓或者根本就不存在。特别是当这个时间间隔仅仅是几秒钟，对于具体沟通资产转移的用户来讲，这个过程是隐蔽的或确实可以接受的，且保证了结果的最终一致性。

当然，对于这样的系统，如果确实需要查看系统的某个一致性状态，可以采用额外的方法实现。

一般来讲，服务之间的一致性比服务内部的一致性要更加容易弱化，这也是为什么 `XA` 等直接在资源层面上实现通用分布式事务的模型会注重一致性的保证，而当上升到服务层面，服务与服务之间已经实现了功能的划分，逻辑的解耦，也就更容易弱化一致性，这就是 `SOA` 架构下 `BASE` 理论的最终一致性思想。

`BASE` 理论是指 `BA`（`Basic Availability` ，基本业务可用性）；`S`（`Softstate` ，柔性状态）；`E`（`Eventualconsistency` ，最终一致性）。该理论认为为了可用性、性能与降级服务的需要，可以适当降低一点一致性的要求，即“基本可用，最终一致”。

业内通常把严格遵循 `ACID` 的事务称为刚性事务；而基于 `BASE` 思想实现的事务称为柔性事务。柔性事务并不是完全放弃了 `ACID` ，仅仅是放宽了一致性要求：事务完成后的一致性严格遵循，事务中的一致性可适当放宽；

## 参考

- [趁热打铁-再谈分布式事务](https://www.cnblogs.com/rickiyang/p/13704868.html)

- [一篇文章带你学习分布式事务](https://www.infoq.cn/article/g1avp9fua6cdoyralv4r)

- [分布式架构设计篇(八)-柔性事务之TCC详解](https://cloud.tencent.com/developer/article/1653162)
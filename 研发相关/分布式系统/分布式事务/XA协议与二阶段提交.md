# XA协议与二阶段提交

## XA协议

`XA` 的全称是 `eXtended Architecture`，它是一个分布式事务协议，通过二阶段提交协议保证强一致性。 `XA` 协议定义了交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。而 `XA` 接口函数由数据库厂商提供。

### 核心模型

`XA` 规范中定义了分布式事务处理模型，这个模型中包含四个核心角色：

- RM (Resource Managers)

    资源管理器，提供数据资源的操作、管理接口，保证数据的一致性和完整性。最有代表性的就是数据库管理系统，当然有的文件系统、`MQ` 系统也可以看作 `RM` 。

- TM (Transaction Managers)

    事务管理器，是一个协调者的角色，协调跨库事务关联的所有 `RM` 的行为。一般是交易中间件。

- AP (Application Program)

    应用程序，按照业务规则调用 `RM` 接口来完成对业务模型数据的变更，当数据的变更涉及多个 `RM` 且要保证事务时， `AP` 就会通过 `TM` 来定义事务的边界， `TM` 负责协调参与事务的各个 `RM` 一同完成一个全局事务。

- CRMs (Communication Resource Managers)

    主要用来进行跨服务的事务的传播。一般是消息中间件。


## 二阶段提交（2PC）

`2PC` 全称 `Two-phaseCommit` ，中文名是二阶段提交，是 `XA` 规范的实现思路。二阶段提交，顾名思义就是要分两步提交。存在一个负责协调各个本地资源管理器的事务管理器，本地资源管理器一般是由数据库实现，事务管理器在第一阶段的时候询问各个资源管理器是否都就绪？如果收到每个资源的回复都是 `yes` ，则在第二阶段提交事务，如果其中任意一个资源的回复是 `no` ,则回滚事务。

![20201221155429](http://cdn.heroxu.com/20201221155429.png)

### 事务流程

- 第一阶段（prepare）

    事务管理器向所有本地资源管理器发起请求，询问是否是 `ready` 状态，所有参与者都将本事务能否成功的信息反馈发给协调者；

- 第二阶段 (commit/rollback)

    事务管理器根据所有本地资源管理器的反馈，通知所有本地资源管理器，步调一致地在所有分支上提交或者回滚。

## XA实现如何保证ACID

### 原子性（Atomicity）

`2PC` 可以保证每次事务的原子性。

### 隔离性（Isolation）

`XA` 协议中没有描述如何实现分布式事务的隔离性，但是 `XA` 协议要求每个资源管理器都要实现本地事务，也就是说基于 `XA` 协议实现的分布式事务的隔离性是由每个资源管理器本地事务的隔离性来保证的，当一个分布式事务的所有子事务都是隔离的，那么这个分布式事务天然的就实现了隔离性。

以 `MySQL` 来举例， `MySQL` 使用 `2PL`（ `Two-PhaseLocking` ，两阶段锁）机制来控制本地事务的并发，保证隔离性。 `2PL` 与 `2PC` 类似，也是将锁操作分为加锁和解锁两个阶段，并且保证两个阶段完全不相交。加锁阶段，只加锁，不放锁。解锁阶段，只放锁，不加锁。

![20201221170713](http://cdn.heroxu.com/20201221170713.png)

如上图所示，在一个本地事务中，每执行一条更新操作之前，都会先获取对应的锁资源，只有获取锁资源成功才会执行该操作，并且一旦获取了锁资源就会持有该锁资源直到本事务执行结束。 `MySQL` 通过这种 `2PL` 机制，可以保证在本地事务执行过程中，其他并发事务不能操作相同资源，从而实现了事务隔离。


### 一致性（Consistency）

一致性有两层语义，一层是确保事务执行结束后，数据库从一个一致状态转变为另一个一致状态，数据最终一致。另一层语义是事务执行过程中的中间状态不能被别的事务观察到。

前一层语义的实现很简单，通过原子性、隔离性以及 `RM` 自身一致性的实现就可以保证。至于后一层语义，我们先来看看单个 `RM` 上的本地事务是怎么实现的。还是以 `MySQL` 举例， `MySQL` 通过 `MVCC`（ `Multi Version Concurrency Control` ，多版本并发控制）机制，为每个一致性状态生成快照（Snapshot），每个事务看到的都是各 `Snapshot` 对应的一致性状态，从而也就保证了本地事务的中间状态不会被观察到。

虽然单个 `RM` 上实现了 `Snapshot` ，但是在分布式应用架构下，会遇到什么问题呢？

![20201221180544](http://cdn.heroxu.com/20201221180544.png)

如上图所示，在 `RM1` 的本地子事务提交完毕到 `RM2` 的本地子事务提交完毕之间，只能读到 `RM1` 上子事务执行的内容，读不到 `RM2` 上的子事务。也就是说，虽然在单个 `RM` 上的本地事务是一致的，但是从全局来看，一个全局事务执行过程的中间状态被观察到了，全局一致性就被破坏了。

`XA` 协议并没有定义怎么实现全局的 `Snapshot` ，像 `MySQL` 官方文档里就建议使用串行化的隔离级别来保证分布式事务一致性： `“As with nondistributed transactions, SERIALIZABLE may be preferred if your applications are sensitive to read phenomena. REPEATABLE READ may not be sufficient for distributed transactions.”`（对于分布式事务来说，可重复读隔离级别不足以保证事务一致性，如果你的程序有全局一致性读要求，可以考虑串行化隔离级别.）

当然，由于串行化隔离级别的性能较差，所以很多分布式数据库都自己实现了分布式 `MVCC` 机制来提供全局的一致性读。一个基本思路是用一个集中式或者逻辑上单调递增的东西来控制生成全局 `Snapshot` ，每个事务或者每条 `SQL` 执行时都去获取一次，从而实现不同隔离级别下的一致性。比如 `Google` 的 `Spanner` 就是用 `TrueTime` 来控制访问全局 `Snapshot` 。

## XA实现存在的问题

- 同步阻塞：当参与事务者存在占用公共资源的情况，其中一个占用了资源，其他事务参与者就只能阻塞等待资源释放，处于阻塞状态。

- 单点故障：一旦事务管理器出现故障，整个系统不可用。

- 数据不一致：在阶段二，如果事务管理器只发送了部分 `commit` 消息，此时网络发生异常，那么只有部分参与者接收到 `commit` 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。

- 不确定性：当事务管理器发送 `commit` 之后，并且此时只有一个参与者收到了 `commit` ，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。


## 参考

- [分布式理论(三) - 2PC协议](https://juejin.cn/post/6844903621495095309#heading-7)

- [浅谈事务和一致性：刚性or柔性？](https://juejin.cn/post/6844903575756210184)

- [趁热打铁-再谈分布式事务](https://www.cnblogs.com/rickiyang/p/13704868.html)

- [一篇文章带你学习分布式事务](https://www.infoq.cn/article/g1avp9fua6cdoyralv4r)

- [分布式事务之解决方案（XA和2PC）](https://cloud.tencent.com/developer/article/1547146)
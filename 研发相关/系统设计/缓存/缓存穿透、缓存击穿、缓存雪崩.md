# 缓存穿透、缓存击穿、缓存雪崩


## 缓存穿透

- 原因

    缓存穿透指查询一个一定不存在的数据。由于缓存是命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。
    
    在流量大时，可能DB就挂掉了，如果有人利用不存在的key频繁攻击我们的应用，这就是漏洞。

- 解决方案

    - 缓存不存在的数据

        如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会设置得很短。

    - 过滤会造成穿透的查询

        将所有可能存在的数据哈希到一个足够大的 `bitmap` 中，一个一定不存在的数据会被 这个 `bitmap` 拦截掉，从而避免了对底层存储系统的查询压力。

## 缓存雪崩

- 原因

    缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。

- 解决方案

    - 随机缓存过期时间

        避免同时过期，可以将缓存的过期时间增加一个随机值，比如1-5分钟。这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。

    - 不在同一时间缓存

        用加锁或者队列的方式保证缓存的单线 程（进程）写，从而避免失效时大量的并发请求落到底层存储系统上。

## 缓存击穿

- 原因

    缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。

- 解决方案

    - 使用互斥锁(mutex key)

        就是在缓存失效的时候（判断拿出来的值为空），不是立即去 `load db` ，而是先使用缓存工具的某些带成功操作返回值的操作（比如 `Redis` 的 `SETNX` 或者 `Memcache` 的 `ADD`）去 `set` 一个 `mutex key` ，当操作返回成功时，再进行 `load db` 的操作并回设缓存；否则，就重试整个 `get` 缓存的方法。

    - 提前更新

        在 `value` 内部设置 `1` 个超时值（timeout1），比实际的超时值小（timeout2）。当从 `cache` 读取到 `timeout1` 发现它已经过期时候，马上延长 `timeout1` 并重新设置到 `cache` 。然后再从数据库加载数据并设置到 `cache` 中。相当于在过期之前提前更新缓存数据。

    - "永远不过期"

        - `redis` 不设置过期时间

        - 为了避免数据成静态的，把过期时间存在 `key` 对应的 `value` 里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建

    - 使用Hystrix做资源的隔离保护主线程池


---

面试的时候被问了一个问题：如何保证 `DB` 的数据实时更新到缓存？

想法：

- 首先想到的是业务是否需要实时更新，因为本身缓存设置超时时间的话就是以时间间隔来更新的。所以业务不需要强一致实时性的数据的话可以不考虑这个问题。

- 如果要更新，肯定不可能缓存去轮训，希望能由 `DB` 这边通知更新


资料查询：

- 数据库和 `redis` 分别处理不同的数据类型

- 使用脚本通知 `redis` 更新

    `MySQL binlog` 增量订阅消费+消息队列+处理并把数据更新到 `redis`